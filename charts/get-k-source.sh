# bash get-k-source.sh

# INPUT_FILE="../Unihan/Unihan_IRGSources.txt"
# head -n 66 "../Unihan/Unihan_IRGSources.txt" > "./test.txt" # 複製前100列當成測試資料
INPUT_FILE="./test.txt" # 如果要測試，可以生一個小一點的測試資料
OUTPUT_FILE="./kIRG_Source_mapping.md"

list_kFields() {
  # -F'\t'設定使用Tab當成分隔符
  # {print} 可以抓印結果, 可以再使用$2表示取第二項數據
  # grep -v '^#' "$INPUT_FILE" | awk -F'\t' '{print $2}'

  # 提取所有第二列数据（跳过以 # 开头的行）
  types=$(
  grep -v '^#' "$INPUT_FILE" |
  awk -F'\t' '{print $2}' | sort | uniq
  )

  # return
  echo "$types"
}

# kCompatibilityVariant, kIICore, ..., kTotalStrokes
k_types=$(list_kFields)
echo -e '\033[44mlist kFields\033[0m'
for type in $k_types; do
    echo "\"$type\""
done

# 再篩選一次，只要kIRG的項目就好
# kSource=$(echo "$k_types" | tr ' ' '\n' | grep ^kIRG)
# echo "$kSource"


# declare -A mapping # 如果少了declare結果會不對
# mapping=(
#   ["kIRG_JSource"]="日本"
# )

# 可以直接宣告加初始化
declare -A mapping=(
  ["kIRG_GSource"]="中國和新加坡"
  ["kIRG_JSource"]="日本"
  ["kIRG_TSource"]="TCA"
  ["kIRG_KPSource"]="北韓"
  ["kIRG_KSource"]="韓國"
  ["kIRG_MSource"]="澳門特別行政區"
  ["kIRG_SSource"]="SAT Daizōkyō 文字資料庫委員會"
  ["kIRG_HSource"]="香港特別行政區"
  ["kIRG_UKSource"]="英國"
  ["kIRG_USource"]="UTC"
  ["kIRG_VSource"]="越南"
)

# 初始化結果
declare -A results

echo -e '\033[44mget IRG set\033[0m'
while IFS=$'\t' read -r unicode key value; do
  [[ "$unicode" =~ ^# ]] && continue

  echo "$unicode" # 使知道程式還有在執行

  # 僅處理 kIRG_* 開頭的 key (例如 "T4-2224" 的前綴)
  if [[ "$key" =~ ^kIRG_ ]]; then
    # 提取值的前綴部分，例如 "T4", "T6"
    ## %% **最贪婪匹配**（greedy match）
    prefix=${value%%-*}
    echo "prefix $prefix"

    cur_group="${results["$key"]}"
    # if [[ ! "$cur_group" =~ $prefix ]]; then
    if [[ ! "$cur_group" = "$prefix" ]]; then # 用這樣即可，不需要用到正規式
        results["$key"]+="$prefix "
    fi
  fi

done < "$INPUT_FILE"
# echo "$results" # <-- `declare -A results` 宣告了一個關聯數組，但你嘗試直接用 `echo "$results"` 打印整個數組，這是無效的。Bash 不支持直接打印關聯數組的方式，因此會導致輸出的 `$results` 看起來是空的

echo -e "\033[44mWrite to $OUTPUT_FILE\033[0m"

{
 echo "> DO NOT EDIT, THIS FILE IS AUTOMATICALLY GENERATED BY \`get-k-source.sh\`"
 echo ""
} > $OUTPUT_FILE # 重寫檔案


echo "| 來源 | 相關代號 | 描述 |" >> $OUTPUT_FILE
echo "| ---- | ---- | ---- |" >> $OUTPUT_FILE
for key in "${!results[@]}"; do
  values="${results[$key]}"
  if [[ -n "${mapping[$key]}" ]]; then
    desc="${mapping[$key]}"
    echo "| $key | $values | $desc |" >> $OUTPUT_FILE
  else
    echo "| $key | $values | |" >> $OUTPUT_FILE
  fi
done
